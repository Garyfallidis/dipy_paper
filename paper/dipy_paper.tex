\documentclass{bioinfo}
\usepackage{url}

\usepackage[british,english]{babel}
\usepackage{mathpazo}
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}

\usepackage{listings}
\usepackage{setspace}

\definecolor{Code}{rgb}{0,0,0}
\definecolor{Decorators}{rgb}{0.5,0.2,0.2}
\definecolor{Numbers}{rgb}{0.5,0,0}
\definecolor{MatchingBrackets}{rgb}{0.25,0.5,0.5}
\definecolor{Keywords}{rgb}{0,0.6,0}
\definecolor{self}{rgb}{0,0,0}
\definecolor{Strings}{rgb}{0.6,0.2,0}
\definecolor{Comments}{rgb}{0,0.63,1}
\definecolor{Backquotes}{rgb}{0,0,0}
\definecolor{Classname}{rgb}{0,0,0}
\definecolor{FunctionName}{rgb}{0,0,0}
\definecolor{Operators}{rgb}{0,0,0}
\definecolor{Background}{rgb}{1,1,1}
\definecolor{Modules}{rgb}{0,0,0.8}

\lstnewenvironment{python}[1][]{
\lstset{
%numbers=left,
numberstyle=\footnotesize,
numbersep=1em,
xleftmargin=0em,
framextopmargin=2em,
framexbottommargin=2em,
showspaces=false,
showtabs=false,
showstringspaces=false,
%frame=l,
tabsize=4,
% Basic
basicstyle=\ttfamily\footnotesize\setstretch{1},
backgroundcolor=\color{Background},
language=Python,
% Comments
commentstyle=\color{Comments}\slshape,
% Strings
stringstyle=\color{Strings},
morecomment=[s][\color{Strings}]{"""}{"""},
morecomment=[s][\color{Strings}]{'''}{'''},
% keywords
morekeywords={import,from,class,def,for,while,if,is,in,elif,else,not,and,or,print,break,continue,return,True,False,None,access,as,del,except,exec,finally,global,import,lambda,pass,print,raise,try,assert},
keywordstyle={\color{Keywords}\bfseries},
% additional keywords
morekeywords={[2]@parametric},
keywordstyle={[2]\color{Decorators}\slshape},
emph={self},
emphstyle={\color{self}\slshape},
%
}}{}


\usepackage[T1]{fontenc}
% \usepackage[latin9]{inputenc}
\usepackage{float}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{setspace}
\usepackage{amssymb}
\usepackage{natbib}
\usepackage[title]{appendix}
\usepackage{siunitx}
\usepackage{chngcntr}
\usepackage{algorithmic}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

\usepackage{multirow}
\usepackage{rotating}
\usepackage{hyperref}

\makeatletter
\newfloat{algorithm}{H}{loa}[section]
\floatname{algorithm}{Algorithm}
\counterwithout{algorithm}{algorithm}
\def\argmin{\mathop{\operator@font arg\,min}} 
\def\argmax{\mathop{\operator@font arg\,max}} 
\makeatother

\copyrightyear{}
\pubyear{}

\begin{document}
\firstpage{1}

\title[QuickBundles]{Dipy, a library for the analysis of diffusion MRI data}

\author[Garyfallidis, Brett, Amirbekian, Rokem,  van der Walt, Descoteaux, 
Nimmo-Smith]{Eleftherios~Garyfallidis\,$^{1,2,*}$, Matthew~Brett\,$^{3}$,
  Bago~Amirbekian\,$^{4}$, Ariel~Rokem\,$^{5}$, Stefan~van der Walt\,$^{7}$, Maxime~Descoteaux\,$^{2}$, Ian~Nimmo-Smith\,$^{6}$ and Dipy~Contributors $^{8}$\footnote{to whom correspondence should be addressed. e-mail: garyfallidis@gmail.com}}

\address{\,$^{1}$University of Cambridge, Cambridge, UK\\
  \,$^{2}$University of Sherbrooke, Sherbrooke, CA\\ 
  \,$^{3}$University of California, Henry H. Wheeler, Jr. Brain Imaging Center, Berkeley, CA.\\
  \,$^{4}$University of California, San Francisco, CA, USA\\    
  \,$^{5}$Stanford University, Stanford, CA, USA\\
  \,$^{6}$MRC Cognition and Brain Sciences Unit, Cambridge, UK\\
  \,$^{7}$Stellenbosch University, Stellenbosch, South Africa\\
  \,$^{8}$http://dipy.org/developers.html  
  }

\history{}

\editor{}

\maketitle

\begin{abstract}
\noindent

Diffusion Imaging in Python (Dipy) is a free and open source software
project for the analysis of data from diffusion magnetic resonance
imaging (dMRI) experiments. DMRI is an application of MRI that can be
used to measure the micro-structure of the white matter in the human
brain in vivo. It utilizes the application of directionally oriented
magnetic gradients to estimate diffusion in different directions and
locations in the brain non-invasively. Many methods have been developed
to model the local configuration of nerve fibers in the white matter
based on this information and to infer the trajectory of fascicles
connecting different parts of the brain. Dipy gathers implementations 
of all these different methods, where they can be easily understood and 
compared. Dipy aims to provide transparent implementations for all the 
different steps of dMRI analysis with a relatively uniform API.

Dipy implements classical signal reconstruction techniques, such as the
diffusion tensor model and deterministic fiber tractography. 
In addition, it implements cutting edge novel reconstruction techniques, 
such as constrained spherical deconvolution and diffusion spectrum imaging 
with deconvolution, as well as methods for probabilistic
tracking and unique methods for tractography clustering. Many additional 
utility functions, to calculate various statistics of dMRI data, visualization
functions, as well as file-handling routines exist to assist in the
development of novel techniques.
 
Dipy makes use of the scientific software for neuroimaging that exists
in python (e.g. nibabel), as well as python tools for numerical
processing (numpy), visualization (python-vtk), high performance
computation (cython) and software testing (nose).

In contrast to many other scientific software projects, dipy is not
being developed by a single research group. Rather, it is an open
project that encourages contributions from any scientist-developer
through the github Pull Request mechanism and open discussions on github
and on the project mailing list. Consequently, dipy has today an
international team of contributors, spanning 6 different academic
institutions in 4 countries and 3 continents, and still growing
(http://dipy.org).

\section{Keywords:} Python, Diffusion MRI, Diffusion Tensor,
Spherical Deconvolution, Medical imaging, Free Open Source Software, Deterministic
tractography, Probabilistic tractography, Fiber tracking, Medical Visualization.

\end{abstract}

\section{Skeleton}
Here is a possible outline for the paper:
\begin{verbatim}
Introduction
Philosophy/Mission
General Design Aspects
How we work (git/github etc)
File Formats 
Preprocessing
   Load/Save data
   Mask the background
Reconstruction
   DTI 
   DSI
   QBall
   Spherical Deconvolution 
Tracking
   Deterministic
   Probabilistic
Post-tracking
   Segmentation
   Track\_counts
   Track Lengths & other statistics
   Connectivity matrix
Discussion/Conclusions
\end{verbatim}

\section{Introduction}

\emph{Diffusion MRI} (dMRI) \citep{stejskal-tanner:65, lebihan-breton:85,merboldt-hanicke-etal:85, taylor-bushell:85, callaghan:91} is the principal non-invasive method that provides information about the directional structure of neuronal pathways found in the white matter and other body tissue with fiber-like structure. dMRI acquires one or 
more $T_{2}$ reference images, and a collection of diffusion-weighted images that attenuate the $T_{2}$ signal according to the amount of diffusion along prescribed gradient directions \citep{behrens-johansen-berg:09, jones:10}.

Because of its unique capability to depict structural connectivity, during the last 10 years, dMRI had an increasing popularity with more than five thousand papers published according to PubMed only for 2012. This popularity is also evident from the large number of software tools available for the analysis of diffusion weighted images. Most of these tools are written in C/C++: 3D Slicer \citep{pieper:06}, AFNI \citep{cox-afni:12}, MITK \citep{fritzsche-mitk:12}, BrainVoyager QX \citep{goebel-brainvoyager:12}, DTI-Query/Quench \citep{sherbondy:05}, FreeSurfer \citep{fischl-freesurfer:12}, FSL-FDT \citep{smith-fdt:04}, MedInria \citep{toussaint-souplet-etal:07}, MRtrix \citep{Tournier2012}, Diffusion Toolkit/Trackvis \citep{wang-diffusion-toolkit:07}, FiberNavigator \citep{vaillancourt:11, chamberland:13}. A few only are written in other languages as R: TractoR \citep{ clayden-TractoR:11}, Java: Camino \citep{Cook2006} and Matlab: ExploreDTI \citep{leemans-exploredti:09}. 

Dipy which stands for \textit{Diffusion Imaging in Python} is the first collective effort to create a diffusion MRI analysis library using the Python language. Python is a general purpose, object-oriented programming language which emphasizes in code readability. Code readability, a key feature of Python enables people who are not necessarily programming gurus to understand and extend the underlying code in a simple and comprehensive manner. We think that this is a powerful asset for the design of the next generation of medical imaging analysis tools. In the past we found that many researchers were using available tools without understanding the underlying details, often because the details were hidden from the users. Dipy tackles this problem be being free, open source (BSD license), simple and well documented. In addition, the recent explosion of Python users, the many Python tools for scientific computing \citep{perez_python:11}, \citep{mckinney_python:12}, \citep{perez_ipython:07} and the recent stack of neuroimaging\footnote{\url{http://nipy.org}} modules make Dipy a nice addition for those who prefer Python as their favorite language.

Dipy is built on top of production-ready high-performance Python libraries. Primarily, Dipy uses the Numpy Array \citep{van_numpy:11} as its core structure. Numpy arrays are the standard representation for numerical data in Python and enable efficient implementation of numerical computations allowing vectorizing calculations, avoiding copying data in memory, and minimizing operations. The Numpy Array is part of a more general numerical library (Numpy\footnote{\url{http://numpy.org}}) which can be used for example for matrix, tensor and linear algebra operations. Dipy also depends on Scipy\footnote{\url{http://scipy.org}} (a superset of Numpy) for nonlinear optimization and other volumetric operations. Cython\footnote{\url{http://cython.org}} is used in rare cases when both standard Python and Numpy/Scipy are not efficient enough for the task at hand. Cython interprets Python code into plain C performance by adding static type declarations. The last hard dependency for Dipy is Nibabel\footnote{\url{http://nipy.org/nibab}} which is used for loading and saving medical imaging file formats.

Furthermore, Dipy recommends the use of IPython\footnote{\url{http://ipython.org}} for interacting with the datasets and debugging the code, the IPython notebook for teaching, Matplotlib\footnote{\url{http://matplotlib.org}} for plotting 2D/3D datasets and Python-VTK\footnote{\url{http://vtk.org}} for more advanced 3D interactive visualization. Nonetheless, these are optional dependencies and they are not required for the standard use of Dipy.

In the following sections, we will explain the philosophy and main design concepts behind Dipy. We will also give examples which cover different parts of the diffusion MR analysis pipeline from the local voxel reconstruction of orientation distribution functions to streamline generation and visualization. 

\section{Philosophy and Mission}

Mission: The purpose of Dipy is to make it easier to do better diffusion MR imaging research. We aim to build software that is clearly written, clearly explained, well tested, a good fit for the underlying ideas and a natural home for collaboration. We hope that, if we fail to do this, you will let us know and we will try and make it 
better.

Dipy is a true international project where everyone from everywhere in the world is welcome to contribute as long as they agree with our mission statement. For example, lets assume that one has made a nice new discovery and wants to share some code. Even if the discovery is very important the code will not be included in the main project without tests and code reviews from other members of the team. In that way we make sure that we keep quality assurance at a high level and we increase the life span of the project by making sure that at least two or three developers are familiar with the submitted shared code.

Using this work ethic Dipy has managed to grow into an international and multi-departmental team of highly skilled contributors from different levels of education (Master students, PhD students, Post-Docs and Professors) spanning the fields of Computer Science, Medicine, Applied Mathematics, Biomedical Engineering and Psychology. 


\section{Terminology}

In the recent paper of \citep{Cote2013tractometer} a specific terminology for dMRI was suggested. We think that this suggestion is reasonable and we would like to use the same terms in this paper. 

Fiber: a long and thin structure. Hence, fiber tracking is a general term that can be
used in any field that reconstructs fibrous structures, such as hair fibers, celery fibers, muscle fibers,
prostate fibers, brain fibers, etc.

Axon: the long fiber-like part of a nerve cell along which impulses are conducted from the cell ($\mu$m scale). 

Tract: a group of neuronal axons in the central nervous system (mm scale).

Fiber bundle: a group of fibers usually with an anatomical or functional meaning, e.g.
arcuate fasciculus, fornix, etc. A fiber bundle for the area of brain anatomy is synonymous to a
tract, also often called fiber tract. The term tract can be misleading when talking for example about
the corticospinal tract. The corticospinal tract is not a single tract but a group of tracts.

Streamline: an imaginary line approximating the underlying fiber. This is synonymous with a track or curve. 

Streamlines bundle(or simply bundle): a group of streamlines with similar shape and spatial characteristics. These do not necessarily correspond to individual fiber bundles. 

Tractography: the process of generating streamlines of brain fibers. This is synonymous with fiber tracking in the central nervous system.


\section{General design aspects}

API (module diagram), Git/Github, continuous integration, sphinx for documentation, nosetests for testing

Need a diagram with the base (numpy, nibabel) and the rest of the modules on top.

Dipy contains the following modules

\tiny
\begin{verbatim}
| modules       | main usage                | sub-modules                        |
| ------------- | ------------------------- | ---------------------------------- |
| reconst       | reconstruction modules    | dti, dsi, csd, odf, shm, gqi       |
| tracking      | tractography algorithms   | EuDX, Modular tracking (det, prob),|
|               |                           | distances, metrics, utils          |
| core          | general usage functions   | spheres, gradients, electrostatics,|
|               |                           | geometry, ndindex                  |       
| viz           | 2D/3D visualization       | fvtk, 2D sphere plots, colormaps   |
| io            | input/io utilities        | pickles, gradients, dpy(HDF5)      |
| external      | other software            | fsl                                |
| align         | alignment, reslicing      | aniso2iso                          |
| sims          | voxel & volume simulations| voxel, phantom                     |
| data          | small data & online data  | fetcher                            |
| segment       | clustering & segmentation | quickbundles                       |

There are also some command line scripts in dipy/bin and many tests.
\end{verbatim}
\normalsize

\begin{python}
import dipy
dipy.__version__
'0.7.0.dev'
\end{python}

\section{Preprocessing}

\subsection{Load/Save data}

\begin{python}
fimg = "raw.nii.gz"
import nibabel as nib
img = nib.load(fimg)
data = img.get_data()
\end{python}

\subsection{Background removal}

\begin{python}
from dipy.segment.mask import hist_mask
mask = hist_mask(data[..., 0])
\end{python}

\section{Reconstruction}

\subsection{Diffusion Tensor Imaging}

The diffusion tensor model is a model that describes the diffusion within a
voxel. First proposed by Basser and colleagues \citep{basser-mattiello-etal:94}, it has been very
influential in demonstrating the utility of diffusion MRI in characterizing the
micro-structure of white matter tissue and of the biophysical properties of
tissue, inferred from local diffusion properties and it is still very commonly
used.

The diffusion tensor models the diffusion signal as:
\begin{eqnarray*}
\frac{S(\mathbf{g}, b)}{S_0} = e^{-b\mathbf{g}^T \mathbf{D} \mathbf{g}}
\end{eqnarray*}
Where $\mathbf{g}$ is a unit vector in 3 space indicating the direction of
measurement and b are the parameters of measurement, such as the strength and
duration of diffusion-weighting gradient. $S(\mathbf{g}, b)$ is the
diffusion-weighted signal measured and $S_0$ is the signal conducted in a
measurement with no diffusion weighting. $\mathbf{D}$ is a positive-definite quadratic
form, which contains six free parameters to be fit. These six parameters are:
\begin{eqnarray*}
\mathbf{D} = \begin{pmatrix}
D_{xx} & D_{xy} & D_{xz} \\ 
D_{yx} & D_{yy} & D_{yz} \\ 
D_{zx} & D_{zy} & D_{zz}
\end{pmatrix}
\end{eqnarray*}
This matrix is a variance/covariance matrix of the diffusivity along the three
spatial dimensions. Note that we can assume that diffusivity has antipodal
symmetry, so elements across the diagonal are equal. For example:
$D_{xy} = D_{yx}$. This is why there are only 6 free parameters to estimate
here.

In the following example we show how to reconstruct your diffusion datasets
using a single tensor model.

\begin{python}
fimg = "raw.nii.gz"
fbval = "raw.bval"
fbvec = "raw.bvec"

import nibabel as nib
img = nib.load(fimg)
data = img.get_data()

from dipy.io import read_bvals_bvecs
bvals, bvecs = read_bvals_bvecs(fbval, fbvec)

from dipy.core.gradients import gradient_table
gtab = gradient_table(bvals, bvecs)

from dipy.reconst.dti import TensorModel
ten = TensorModel(gtab)
tenfit = ten.fit(data)

from dipy.reconst.dti import fractional_anisotropy
fa = fractional_anisotropy(tenfit.evals)

from dipy.reconst.dti import color_fa
cfa = color_fa(fa, tenfit.evecs)

from dipy.reconst.dti import tensor_sphericity
sph = tensor_sphericity(tenfit.evals)

\end{python}

\citep{westin:97}

\subsection{Diffusion Spectrum Imaging}

\subsection{QBall Imaging}

\subsection{Constrained Spherical Deconvolution} 

\section{Fiber tracking}

\subsection{Deterministic}

\subsection{Probabilistic}

\section{Post-tracking}

\subsection{Segmentation}

\subsection{ROIs - streamlines intersections}

Talk about track\_counts.

\subsection{Streamline statistics}

Talk about lenghts and other metrics on streamlines

\section{Discussion/Conclusion}

\section*{Acknowledgments}
Who do we need to acknowledge?

\section*{Disclosure/Conflict-of-Interest Statement}
There are no conflicts of interest.

\section{LaTex Formatting}

This is information for the coauthors of this paper. This section will be removed from the last version of this paper.

This is to show how graphics (EPS) files are included. We use EPS for
speed. The first one is spread across both columns, and the second one
is just in a single column:

\begin{figure*}
\centerline{\includegraphics[width=160mm]{Figures/Fig_4_cst_simplification_relabeled_triple.eps}}
\caption{This is the figure caption - and a label to refer to it in the text \label{Fig:big_picture}}
\end{figure*}

When we want to refer to this figure we use the label (see Fig.~\ref{Fig:big_picture}).

\begin{figure}
\includegraphics[scale=0.15]{Figures/Fig_11_MDF_arcuate}
\centering{}
\caption{Color coding shows MDF distances from QB centroid to every
  other track in the bundle.\label{Fig:little_picture}}
\end{figure}

Here are some displayed equations (see Eq.~\ref{eq:direct_flip_distance}):
\begin{eqnarray}
  d_{\textrm{direct}}(s, t) = d(s, t) & = & \frac{1}{K}\sum_{i=1}^{K}|s_{i}-t_{i}|,\nonumber\\
  d_{\textrm{flipped}}(s, t) & = & d(s,t^F) = d(s^F,t),\nonumber\\
  \textrm{MDF}(s, t) & = & \min(d_{\textrm{direct}}(s, t), d_{\textrm{flipped}}(s, t))\label{eq:direct_flip_distance}.
\end{eqnarray}

Inline mathematics goes like this: $\frac{1}{K}\sum_{i=1}^{K}|s_{i}-t_{i}|$

Here we have an example of a table (see Table~\ref{Table_1}).

\begin{table}[th] \processtable{QB centroids performance compared with
random subsets\label{Table_1}} {\begin{tabular}{rrrr} %\hline Thresholds &
Comparison & Coverage \% (s.d.) & Overlap (s.d.) \\ \hline
\multirow{2}{*}{$10$~mm/$10$~mm} & QB Centroids & 99.96 (0.007) & 2.44
(0.08)\\ & Random & 90.49 (0.41) & 6.16 (0.55)\\ \hline
\multirow{2}{*}{$20$~mm/$20$~mm} & QB Centroids & 99.99 (0.004) & 3.54
(0.18)\\ & Random & 95.86 (0.62) & 6.81 (0.93)\\ \hline
\end{tabular}}{}
\end{table}

References go like this: in parentheses \citep{Garyfallidis_thesis, Mori1999}, and in running text \citet{Garyfallidis_thesis}.

And here is an example of how to add some code.

\begin{python}
from dipy.viz import fvtk
ren = fvtk.ren()
class Test(object):
  def __init__(self, a):
    pass
@parametric
def f(x):
  return x**2
for i in range(10):
  print f(i)
\end{python}



\selectlanguage{british}%
\bibliographystyle{apalike2}
%\bibliographystyle{plainnat}
%\bibliographystyle{IEEEabrv, IEEEtran}
%\bibliographystyle{IEEEtran}
%\bibliographystyle{elsarticle-harv}
\selectlanguage{english}
\bibliography{scilBibTex}

\end{document}
